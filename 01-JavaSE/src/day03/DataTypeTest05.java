package day03;
/*
  关于java中的整数型
  byte
  short
  int
  long
 */
public class DataTypeTest05 {
  public static void main (String[] args) {
//    100L是long类型字面值
//    x 是long类型变量
//    不存在自动类型转换，直接赋值
    long x = 100L;

//    x变量是long类型，8个字节
//    y是int类型，4个字节
//    以下程序编译报错，大容量不能直接赋值给小容量
//    int y = x;
//    大容量转换成小容量，需要进行强制类型转换
//    需加强制类型转换符
//    加上强制类型转换符之后编译通过了，但有可能损失精度
//    所以强制类型转换谨慎使用，因为损失精度之后可能损失很严重
//    强转原理：
//      原始数据：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
//      强转之后数据：00000000 00000000 00000000 01100100
//      将左边的二进制砍掉【所有的数据强转的时候都是这样完成的】

//    原始数据：00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000
//    强转之后的数据：10000000 00000000 00000000 00000000
//    10000000 00000000 00000000 00000000目前存储在计算机内部，计算机存储数据都是采用补码的形式存储
//    所以10000000 00000000 00000000 00000000现在是一个补码形式
//    将以上的补码转换到原码就是最终的结果
    long k = 2147483648L;
    int e = (int)k;
    System.out.println(e); // 损失精度严重，结果是负数【-2147483648】

//   分析一下程序是否编译通过？
//    依据目前所学内容，以下程序无法编译通过
//    理由：50是int类型的字面值，b是byte类型的变量，显然是大容量int转换成小容量byte
//    大容量转换成小容量是需要添加强制类型转换符的，以下程序没有添加强转符号，所以编译报错。
//    但是，在实际编译的时候，以下编译通过了，这说明：在java语言中，当一个整数型字面值没有超过byte类型取值范围的话，该字面值可以直接赋值给byte类型
    byte b = 50;  // 可以
    byte c = 127; // 可以
//    byte d = 128; 编译报错 128超出了byte类型的取值范围
//    纠正错误，需要使用强制类型转换
//    但是精度一定会损失
//    原始数据
//    原码反码补码
//
//    原码：为二进制的数，如：10    原码0000 1010
//    反码：正数与原码相同，如：10    反码0000 1010
//    负数为原码0变1，1变0，（符号位不变）如：-10 原码1000 1010  反码1111 0101
//    补码：正数的补码与原码相同，如：10     补码0000 1010
//    负数的反码为补码减1，如：-10     反码：1111 0101  补码：1111 0110
//    计算机中数字以补码储存，因为原码和反码计算不准确，而补码是准确的。
  }
}
